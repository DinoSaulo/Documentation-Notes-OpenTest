# [Trabalhando com *test data*](https://getopentest.org/docs/test-data.html)

## Separando o *test data* da lógica dos testes

Uma das melhores práticas bastante utilizadas na automação de testes é  armazenar os dados de teste separadamente da lógica de testes. Há duas razões principais para isso:

- Quando os dados são utilizados frequentemente em vários tipos de teste. Além disso, fazer referências aos dados de teste em um arquivo de dados externos ajuda a duplicá-los facilitando a manutenção.

- Os dados e a lógica de teste tendem a mudar em ritimos diferentes. Separar eles torna mais facil de fazer manutenção e corrigir eventuais erros nos testes.

Abaixo está um exemplo de ação de teste que preenche seu argumento localizador de um arquivo de dados externo chamado `locators.yaml`

```yaml
- description: Digita "react" no campo de busca e aperta Enter
  action: org.getopentest.selenium.SendKeys
  args:
      locator: $data("locators").searchBox
      text: react
      sendEnter: true
```

A sintaxe `$data("locators").searchBox` indica para o actor de testes procurar por uma propriedade chamada `searchBox` no arquivo chamado `locators.yaml`.

OBS: Por convençãom toddos os arquivos de dados de testes devem ser colocados na pasta `data` no repositório de testes. É por isso que quando solicitamos um arquivo de dados usando a sintaxe $data(), não é necessário especificar onde em que diretório está o arquvi, pois é esperado que ele esteja no diretório  `test-repo-path/data`. Mas para isso funcionar é necessário que o arquivo `locators.yaml` seja criado no repositório `test-repo-path/data`.


O arquivo de dados do exemplo acima possui a seguinte estrutura:

`test-repo-path/data/locators.yaml`

```yaml
searchBox: { name: q }
```

O diretório do repositório de teste agora deve ficar dessa forma:

```bash
test-repo
    ├── data
    │   └── locators.yaml
    └── tests
        └── Sample test.yaml
```

Em cenários de automação de teste no mundo real, o arquivo de dados pode se tornar bastante complexo. O OpenTest permite organizar os dados de teste da melhor maneira parra adequar a cenários específicos, como veremos asseguir.

## Dividindo dados de teste entre arquivos e diretórios

O exemplo anterior definiu um arquivo de teste um arquivo de teste chamado de `locators.yaml` que pode ser usado para armazenar a lista completa de localizadores ou *locators* de objetos. No entanto, para um aplicativo maior, você pode querer pensar em dividir os dados em vários arquivos. Uma boa prática sugerida na documentação, é implementar um arquivo de locators para cada página e colocar todos esses arquivos em uma pasta chamada *locators*.

Para dividir os dados dos locator de objetos em vários arquivos ódemos uutilizar uma estrutura de diretórios semelhante à abaixo:

```bash
test-repo
├── data
│   └── locators
│       ├── login.yaml
|       ├── home.yaml
|       └── products.yaml
└── tests
    └── ...
```

Para fazer referência a esses arquivos, podemoa usar a mesma sintaxe `$data()`, desde que especifique o caminho relativo correto para o arquivo de dados que desejamos acessar.

```yaml
- description: Type "react" in the search box and press Enter
  action: org.getopentest.selenium.SendKeys
  args:
      locator: $data("locators/home").searchBox
      text: react
      sendEnter: true
```

OBS: O argumento passado na função `$data()` é o caminho para o arquivo de dados, relativo ao subdiretório de dados do repositório de teste e excluindo a extensão `.yaml`. Por exemplo, a sintaxe `$data("locators/home")` refere-se ao arquivo de dados `test-repo/data/locators/home.yaml`.

## Armazenando dados em uma hierarquia de vários níveis

Como os dados de arquivos são expressos em YAML, é possivel utilizar todo o conjunto de recursos que o YAML traz consigo. Por exemplo, se dividirmos os localizadores de objetos em várias seções em um arquivo YAML, podemos utilizar localizadores utilizando a seguinte estrutura:

`test-repo-path/data/locators.yaml`
```yaml
login:
  username: { id: username }
  password: { id: password }

home:
  searchBox: { name: q }
```

O locator do elemento da caixa de pesquisa na página inicial pode ser acessado usando o operador ponto para navegar por essa hierarquia:

```yaml
$data("locators").home.searchBox
```

Embora as hierarquias de dados possam ser tão profundas quanto precisarmos, é recomendado evitar o uso de mais de dis níveis, para facilitar a leitura e a manutenção dos arquivos de dados.

## Referenciando arquivos de dados de outros arquivos de dados

Embora não pareça uma coisa muito útil é dividir as propriedades de dados de maneira que facilite a capacidade de ler uma propriedade de dados do arquivo e usa-la. Digamos que temos o arquivo chamado `environment.yaml` que armazena as configurações de ambiente para algum conjunto de testes de API
`test-repo-path/data/environment.yaml`
```yaml
baseUrl: https://my.domain.com
username: john_doe
password: sk67E8qL
```

Além disso, é possível armazenar os URLs da várias APIs em um arquivo de dados diferent, encadeando o URL base do arquivo YAML com o restante da URL, da seguinte forma:

`test-repo-path/data/urls.yaml`
```yaml
customerApiUrl: $data("environment").baseUrl + "/customer"
productApiUrl: $data("environment").baseUrl + "/product"
```

OBS: As expressões usadas para construir os URLs das APIS, como vimos acima, são escritos em JavaScript. O actor de teste avaliará as expressões em JS e usará os resultados como valores para as propriedades correspondentes. Veremos mais sobre isso futuramente.

## Gerando dados de teste dinamicamente

