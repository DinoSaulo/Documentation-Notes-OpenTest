# [Tipos de *actions* de teste](https://getopentest.org/docs/test-action-types.html)

## Visão Geral

As *actions* ou ações de um teste são as partes atômicas de um caso de teste que executam uma etapa do teste (por exemplo, clicar em um elemento, fazer uma requisição HTTP e outros). No mundo de automação de teste aas *actions* são chamadas de "*keywords*", ou palavras-chave e a prática de teste correspondente é chamada de teste "*keyword-driven*" ou teste orientado por palavras-chave.
As actions são executadas sequencialmente, seguindo a ordem em que foram especcificadas no arquivo YAML do caso de teste. Cada action pode receber nenhum ou mais argumentos de entrada e pode produzir um ou mais valores de saída que podem ser usados nas actions seguintes.

O OpenTest possui três tipos de ações de teste: ações regulares, ações de script e ações de macro.

## Ações regulares

A maioria das ações de teste regulares que estão presentes no pacote principal do OpenTest, nas novas actions podem ser adicionadas como extensões personalizadas (veremos isso a frente). As actions de teste regulares são implementadas como classes Java que herdam da classe base TestAction.


Uma action de teste regular possui a seguinte estrutura/sintaxe:
```yaml
- description: Esta é um passo de teste de exemplo
  action: org.getopentest.actions.SampleAction
  args:
    argument1: value1
    argument2: value2
```

As três propriedades de uma ação de testes regulares são:

- `description`(option): A descrição é apenas um texto legível para humanos descrevendo que a ação irá fazer no caso de teste em que ela está. A descrição também é usada em logs e em relatórios de execução dos testes, então, criar uma descrição clara e precisa torna muito mais facil de entender o fluxo de execução e para solucionar problemas nos casos de teste com falha.

- `action`: Essa propriedade pe um nome de uma classe Java que implementa alógica da ação de teste (nome do pacote e nome da classe, separadas por um ponto). Por exemplo, para executar a action Click do pacote `org.getopentest.selenium` é utilizado o `org.getopentest.selenium.Click`.

- `args`(opcional): Os argumentos passados para uma ação de teste, para algumas ações podem ser bem simples, ou até nem precisar dessa propriedade (por exemplo, a action SwitchToLastWindow do Selenium), a maioria das ações de teste requerem informações adicionais para serem executadas com sucesso, como um locator de um elemento de uma pagina web para ser clicado, ou um texto para ser digitado em uma caixa de texto. Os argumentos podem ser tipos de dados simples como strings ou números, mas também podem ser complexos, como coleções de pares nome-valor de mapas hash (hash-maps).

## Actions de script

O código JavaScript pode ser inserido em qualquer lugar no fluxo de um caso de teste usando actions de script. Assim como nos outros tipos de ação de teste, as ações de scipt fonecem a propriedade `description`, que é opicional. Já o código JavaScript que será executado deve ser descrito na propriedade `script` como um valor de string da ação de teste.
Abaixo temos um exempolo de action de script que pausa a execução do teste por 2 segundos, implementada usando a função `$delay` presente no OpenTest

```yaml
- description: Pausa a execução do teste por dois segundos
  script: $delay(2000)
```

Para scripts mais complexos, e que necessitam de mais de uma linha, pode sser usado a barra "|" ou pipe, para organizar o script em várias linhas e de forma identada, caso necessário. O exemplo abaixo demonstra a utilização do pipe em uma action de testes:

```yaml
- description: Clicar nos botões com IDs "button1" até "button100"
  script: |
    for (var buttonNo = 1; buttonNo <= 100; buttonNo++) {
        $runAction("org.getopentest.selenium.Click", {
            locator: { id: "button" + buttonNo }
        });
    }
```

## *Macro actions*

Uma macro action ou ação de macro pode conter qualquer sequencia de ações de teste (tanto ações regulares, ações de script ou outros tipos). Essas actions são armazenadas em um arquivo aparte e podem ser chamadas por vários testes.
O objetivo das ações de macro é evitar a duplicação de código e aumentar a legibilidade do teste automatizado. Elas desempenhem um papel muito semelhante ao das funções de programação das linguagens modernas.

Por exemplo, a maioria dos aplicativos ou sistemas requer que o usuário faça login antes de poder fazer algum atividad específica. A maneira correta de realizar a autenticação do ususário seria criando uma macro action chamadda "Login" e depois chamar essa action no início de cada caso de teste que requer o login. Isso pode ser feito da seguinte forma:

```yaml
- macro: Login
```

Para criar a macro de login, vamos criar um novo arquivo chamado Login.yaml no subdiretório de `macros` do repositório de teste, com o seguinte conteúdo:

`test-repo-path/macros/Login.yaml`
```yaml
description: Executa os passos necessários para autenticar o usuário
actions:
  - description: Chama a API de autenticação
    action: org.getopentest.actions.HttpRequest
    args:
      url: https://some.url.here/authenticate?user=john&password=mypasswd
      verb: GET


  # ... executar as outras ações necessárias aqui
```

Assim como todas as actions de teste, as macros podem receber argumentos como entrada e podem produzir alguns valores ne saída. Para passar argumentos para uma ação macro, podemos usar a mesma sintaxe de uma ação normal, como demosntrado abaixo: 

```yaml
- macro: Login
  args:
    username: john_doe
    password: senha_12345
```

Para poder ler os argumentos que poram passados na chamada da macro, podemos utilizar a função do JavaScript `$macroArgs` (Mais detalhes [aqui](https://getopentest.org/reference/javascript-api.html#macroargs)). Para escrever um valor de saída de uma macro action, podemos adicionalos como propriedades do objeto `$macroOutput` (Mais detalhes [aqui](https://getopentest.org/reference/javascript-api.html#macrooutput)).

Vamos supor que temos uma API HTTP que devemos chamarr para autenticar em um serviço web, que retorna o token de autenticação em um JSON no seguinte formato `{"authToken": "kf74F43KL9gSd9dP"}`. O código de exemplo abaixo é uma macro action que usa os argumentos de nome do usuário e senhaa e cri aum valor de sida chamado `authToken` contendo o token de autenticação retornado pela API HTTP. O código também faz uso de alguns outros recursos, como o armazenamento de dados local. Já os comandos $output e $format são documentadas separadamente, portanto, não iremos entender o trecho de código completamente:

`test-repo-path/macros/Login.yaml`
```yaml
description: Autenticando o usuário
actions:
  - script: |
      // Cria o URL de autenticação e armazena o token em uma variável
      var authenticationUrl = $format(
        "https://some.url.here/authenticate?user={0}&password={1}",
        $macroArgs.username,
        $macroArgs.password)

  - description: Chamando a API de autenticação
    action: org.getopentest.actions.HttpRequest
    args:
      url: authenticationUrl
      verb: GET

  - script: $macroOutput.authToken = $output.body.authToken;
```

Agora que ja timos essa macro, podemos chamá-la em todos os testes que exigem o login com a seguinte sintaxe:

```yaml
- macro: Login
  args:
    username: john_doe
    password: senha_12345

- script: $log("The authentication token is " + $output.authToken)
```

Escrever macros geralmente requer um pouco mais de tempo e uma familiaridade grande com um sistema em teste, por isso é recomendado que sejam implementados pelos membros mais experientes de uma equipe. Construir um conjunto macros pode acelerar bastante o desenvolvimento de testes, tornar o conjunto de testes mais fácil de manter e ter um grande impacto no sucesso a longo prazo do esforço de automação de testes.